use bevy::prelude::*;
use bevy_rapier2d::prelude::*;

use crate::Throwable;

pub struct Hooks;

impl<'a> PhysicsHooksWithQuery<&'a ImpulseJoint> for Hooks {
    fn filter_contact_pair(
        &self,
        context: PairFilterContextView,
        query: &Query<&'a ImpulseJoint>,
    ) -> Option<SolverFlags> {
        // Impulse joints are used for the glue effect and so ignore collisions generated by that
        if connected_by_impulse_joint(
            |e| query.get(e).ok(),
            context.collider1(),
            context.collider2(),
        ) {
            return None;
        }
        return Some(SolverFlags::COMPUTE_IMPULSES);
    }
}

pub fn handle_collisions(
    mut commands: Commands,
    world: &World,
    rapier_context: Res<RapierContext>,
    mut collision_events: EventReader<CollisionEvent>,
) {
    for collision_event in collision_events.iter() {
        match collision_event {
            CollisionEvent::Started(a, b, _) => {
                if world.get::<Throwable>(*a).is_none() || world.get::<Throwable>(*b).is_none() {
                    // Colliding entities weren't thrown objects and so we don't glue them together
                    continue;
                }
                if connected_by_impulse_joint(|e| world.get::<ImpulseJoint>(e), *a, *b) {
                    // Objects are already glued together
                    continue;
                }

                let get_rotation = |e| {
                    world
                        .get::<Transform>(e)
                        .map(|t| t.rotation.to_euler(EulerRot::XYZ).2)
                        .unwrap_or_default()
                };

                let rot1 = get_rotation(*a);
                let rot2 = get_rotation(*b);

                // Determine where they collided from the contact graph
                if let Some(contact_pair) = rapier_context.contact_pair(*a, *b) {
                    for manifold in contact_pair.manifolds() {
                        for contact_point in manifold.points() {
                            let (la1, lb1, la2, lb2) = (
                                contact_point.local_p1() * 100.,
                                -rot1,
                                contact_point.local_p2() * 100.,
                                -rot2,
                            );
                            // TODO: Get rid of hardcoded 100
                            // info!("{}, {}, {}, {}", la1, lb1, la2, lb2);

                            // And then glue them together by creating fixed impulse joint between them
                            let joint = FixedJointBuilder::new()
                                .local_anchor1(la1)
                                .local_basis1(lb1)
                                .local_anchor2(la2)
                                .local_basis2(lb2);
                            commands
                                .entity(contact_pair.collider2())
                                .insert(ImpulseJoint::new(contact_pair.collider1(), joint));
                        }
                    }
                }
            }
            _ => {}
        }
        info!("Received collision event: {collision_event:?}");
    }
}

/// Checks if either entity has a impulse joint which parent the other entity is
fn connected_by_impulse_joint<'a, F>(f: F, a: Entity, b: Entity) -> bool
where
    F: Fn(Entity) -> Option<&'a ImpulseJoint>,
{
    return f(a).map(|joint| joint.parent == b).unwrap_or(false)
        || f(b).map(|joint| joint.parent == a).unwrap_or(false);
}
