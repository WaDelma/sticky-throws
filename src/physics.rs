use std::convert::identity;

use bevy::prelude::*;
use bevy_rapier2d::prelude::*;

use crate::{Destroyer, Ghost, Throwable};

pub struct Hooks;

pub type PhysicsData<'a> = (
    Option<&'a ImpulseJoint>,
    Option<&'a Ghost>,
    Option<&'a Parent>,
);

fn get_rec_ghost<'a, 'b>(
    query: &'b Query<PhysicsData<'a>>,
    e: Entity,
) -> Option<(&'b Ghost, Entity)> {
    let (_, ghost, parent) = query.get(e).ok().map_or((None, None, None), identity);
    ghost
        .map(|g| (g, e))
        .or_else(|| parent.and_then(|parent| get_rec_ghost(query, parent.get())))
}

fn find_parent<'a, 'b, F>(query: &'b Query<PhysicsData<'a>>, e: Entity, mut f: F) -> Option<Entity>
where
    F: FnMut(Entity) -> bool,
{
    if f(e) {
        return Some(e);
    }
    let (_, _, parent) = query.get(e).ok().map_or((None, None, None), identity);

    parent.and_then(|p| find_parent(query, p.get(), f))
}

impl<'a> PhysicsHooksWithQuery<PhysicsData<'a>> for Hooks {
    fn filter_contact_pair(
        &self,
        context: PairFilterContextView,
        query: &Query<PhysicsData<'a>>,
    ) -> Option<SolverFlags> {
        let (a, b) = (context.collider1(), context.collider2());
        let ghost_a = get_rec_ghost(query, a);
        if let Some((g, _)) = ghost_a {
            if find_parent(query, b, |e| g.0 == e).is_some() {
                return None;
            }
        }
        let ghost_b = get_rec_ghost(query, b);
        if let Some((g, _)) = ghost_b {
            if find_parent(query, a, |e| g.0 == e).is_some() {
                return None;
            }
        }
        if ghost_a.is_some() && ghost_b.is_some() {
            return None;
        }
        // Impulse joints are used for the glue effect and so ignore collisions generated by that
        let joint_a = query.get(a).ok().and_then(|(j, _, _)| j);
        let joint_b = query.get(b).ok().and_then(|(j, _, _)| j);
        if connected_by_impulse_joint((a, joint_a), (b, joint_b)) {
            return None;
        }
        return Some(SolverFlags::COMPUTE_IMPULSES);
    }
}

fn get_recursively<T>(world: &World, e: Entity) -> Option<(&T, Entity)>
where
    T: Component,
{
    world.get::<T>(e).map(|t| (t, e)).or_else(|| {
        world
            .get::<Parent>(e)
            .and_then(|parent| get_recursively(world, parent.get()))
    })
}

pub fn handle_collisions(
    mut commands: Commands,
    world: &World,
    rapier_context: Res<RapierContext>,
    mut collision_events: EventReader<CollisionEvent>,
) {
    for collision_event in collision_events.iter() {
        match collision_event {
            CollisionEvent::Started(a, b, _) => {
                // `filter_contact_pair` should ensure that both are not ghosts or what ghost was made of
                if let Some((_, e)) = get_recursively::<Ghost>(world, *a) {
                    commands.entity(e).despawn_recursive();
                } else if let Some((_, e)) = get_recursively::<Ghost>(world, *b) {
                    commands.entity(e).despawn_recursive();
                }
                if let (Some((_, e1)), Some((_, e2))) = (
                    get_recursively::<Throwable>(world, *a),
                    get_recursively::<Throwable>(world, *b),
                ) {
                    if connected_by_impulse_joint(
                        (e1, world.get::<ImpulseJoint>(e1)),
                        (e2, world.get::<ImpulseJoint>(e2)),
                    ) {
                        // Objects are already glued together
                        continue;
                    }

                    let get_rotation = |e| {
                        world
                            .get::<Transform>(e)
                            .map(|t| t.rotation.to_euler(EulerRot::XYZ).2)
                            .unwrap_or_default()
                    };

                    let rot1 = get_rotation(*a);
                    let rot2 = get_rotation(*b);

                    // Determine where they collided from the contact graph
                    if let Some(contact_pair) = rapier_context.contact_pair(*a, *b) {
                        for manifold in contact_pair.manifolds() {
                            for contact_point in manifold.points() {
                                let (la1, lb1, la2, lb2) = (
                                    contact_point.local_p1() * 100.,
                                    -rot1,
                                    contact_point.local_p2() * 100.,
                                    -rot2,
                                );
                                // TODO: Get rid of hardcoded 100
                                // info!("{}, {}, {}, {}", la1, lb1, la2, lb2);

                                // And then glue them together by creating fixed impulse joint between them
                                let joint = FixedJointBuilder::new()
                                    .local_anchor1(la1)
                                    .local_basis1(lb1)
                                    .local_anchor2(la2)
                                    .local_basis2(lb2);
                                let (e1, e2) = if *a == contact_pair.collider1() {
                                    (e1, e2)
                                } else {
                                    (e2, e1)
                                };
                                commands.entity(e2).insert(ImpulseJoint::new(e1, joint));
                            }
                        }
                    }
                } else {
                    if let Some((_, e)) = get_recursively::<Throwable>(world, *a) {
                        if world.get::<Destroyer>(*b).is_some() {
                            commands.entity(e).despawn_recursive();
                        }
                    }
                    if let Some((_, e)) = get_recursively::<Throwable>(world, *b) {
                        if world.get::<Destroyer>(*a).is_some() {
                            commands.entity(e).despawn_recursive();
                        }
                    }
                    continue;
                }
            }
            _ => {}
        }
        // info!("Received collision event: {collision_event:?}");
    }
}

/// Checks if either entity has a impulse joint which parent the other entity is
fn connected_by_impulse_joint(
    (a, joint_a): (Entity, Option<&ImpulseJoint>),
    (b, joint_b): (Entity, Option<&ImpulseJoint>),
) -> bool {
    return joint_a.map(|joint| joint.parent == b).unwrap_or(false)
        || joint_b.map(|joint| joint.parent == a).unwrap_or(false);
}
