use std::convert::identity;

use bevy::prelude::*;
use bevy_rapier2d::prelude::*;

use crate::{Destroyer, Ghost, Stuck, Throwable};

pub struct Hooks;

pub type PhysicsData<'a> = (
    Option<&'a ImpulseJoint>,
    Option<&'a Ghost>,
    Option<&'a Parent>,
    Option<&'a Stuck>,
);

fn hook_get_rec_ghost<'a, 'b>(
    query: &'b Query<PhysicsData<'a>>,
    e: Entity,
) -> Option<(&'b Ghost, Entity)> {
    let (_, ghost, parent, _) = query.get(e).ok().map_or((None, None, None, None), identity);
    ghost
        .map(|g| (g, e))
        .or_else(|| parent.and_then(|parent| hook_get_rec_ghost(query, parent.get())))
}

fn hook_find_parent<'a, 'b, F>(
    query: &'b Query<PhysicsData<'a>>,
    e: Entity,
    mut f: F,
) -> Option<Entity>
where
    F: FnMut(Entity) -> bool,
{
    if f(e) {
        return Some(e);
    }
    let (_, _, parent, _) = query.get(e).ok().map_or((None, None, None, None), identity);

    parent.and_then(|p| hook_find_parent(query, p.get(), f))
}

fn hook_find_most_parent<'a, 'b>(query: &'b Query<PhysicsData<'a>>, e: Entity) -> (Entity, bool) {
    let (_, _, parent, stuck) = query.get(e).ok().map_or((None, None, None, None), identity);
    if let Some(p) = parent {
        hook_find_most_parent(query, p.get())
    } else {
        (e, stuck.is_some())
    }
}

impl<'a> PhysicsHooksWithQuery<PhysicsData<'a>> for Hooks {
    fn filter_contact_pair(
        &self,
        context: PairFilterContextView,
        query: &Query<PhysicsData<'a>>,
    ) -> Option<SolverFlags> {
        let (a, b) = (context.collider1(), context.collider2());
        let ghost_a = hook_get_rec_ghost(query, a);
        if let Some((g, _)) = ghost_a {
            if hook_find_parent(query, b, |e| g.0 == e).is_some() {
                return None;
            }
        }
        let ghost_b = hook_get_rec_ghost(query, b);
        if let Some((g, _)) = ghost_b {
            if hook_find_parent(query, a, |e| g.0 == e).is_some() {
                return None;
            }
        }
        if ghost_a.is_some() && ghost_b.is_some() {
            return None;
        }

        // TODO: This does not really work
        // let p1 = hook_find_most_parent(query, a);
        // let p2 = hook_find_most_parent(query, b);
        // if p1 == p2 && p1.1 {
        //     return None;
        // }

        // Impulse joints are used for the glue effect and so ignore collisions generated by that
        // TODO: This does not work with hammer and also break with larger impulse joint chains
        let joint_a = query.get(a).ok().and_then(|(j, _, _, _)| j);
        let joint_b = query.get(b).ok().and_then(|(j, _, _, _)| j);
        if connected_by_impulse_joint((a, joint_a), (b, joint_b)) {
            return None;
        }
        return Some(SolverFlags::COMPUTE_IMPULSES);
    }
}

fn get_recursively<T>(world: &World, e: Entity) -> Option<(&T, Entity)>
where
    T: Component,
{
    world.get::<T>(e).map(|t| (t, e)).or_else(|| {
        world
            .get::<Parent>(e)
            .and_then(|parent| get_recursively(world, parent.get()))
    })
}

fn find_most_parent(world: &World, e: Entity) -> Entity {
    if let Some(p) = world.get::<Parent>(e) {
        find_most_parent(world, p.get())
    } else {
        e
    }
}

pub fn handle_collisions(
    mut commands: Commands,
    world: &World,
    rapier_context: Res<RapierContext>,
    mut collision_events: EventReader<CollisionEvent>,
) {
    for collision_event in collision_events.iter() {
        match collision_event {
            CollisionEvent::Started(a, b, _) => {
                // `filter_contact_pair` should ensure that both are not ghosts or what ghost was made of
                if let Some((_, e)) = get_recursively::<Ghost>(world, *a) {
                    commands.entity(e).despawn_recursive();
                } else if let Some((_, e)) = get_recursively::<Ghost>(world, *b) {
                    commands.entity(e).despawn_recursive();
                }
                if let (Some((_, e1)), Some((_, e2))) = (
                    get_recursively::<Throwable>(world, *a),
                    get_recursively::<Throwable>(world, *b),
                ) {
                    if connected_by_impulse_joint(
                        (e1, world.get::<ImpulseJoint>(e1)),
                        (e2, world.get::<ImpulseJoint>(e2)),
                    ) {
                        // Objects are already glued together
                        continue;
                    }

                    let get_rotation = |e| {
                        world
                            .get::<Transform>(e)
                            .map(|t| t.rotation.to_euler(EulerRot::XYZ).2)
                            .unwrap_or_default()
                    };

                    let rot1 = get_rotation(*a);
                    let rot2 = get_rotation(*b);

                    // Determine where they collided from the contact graph
                    if let Some(contact_pair) = rapier_context.contact_pair(*a, *b) {
                        if let Some((_, contact_point)) = contact_pair.find_deepest_contact() {
                            let (la1, lb1, la2, lb2) = (
                                contact_point.local_p1() * 100.,
                                -rot1,
                                contact_point.local_p2() * 100.,
                                -rot2,
                            );
                            // TODO: Get rid of hardcoded 100
                            // info!("{}, {}, {}, {}", la1, lb1, la2, lb2);

                            // And then glue them together by creating fixed impulse joint between them
                            let joint = FixedJointBuilder::new()
                                .local_anchor1(la1)
                                .local_basis1(lb1)
                                .local_anchor2(la2)
                                .local_basis2(lb2);
                            let (e1, e2) = if *a == contact_pair.collider1() {
                                (e1, e2)
                            } else {
                                (e2, e1)
                            };

                            commands.entity(e2).insert(ImpulseJoint::new(e1, joint));

                            // TODO: This doesnt work:
                            // let p1 = find_most_parent(world, e1);
                            // let p2 = find_most_parent(world, e1);
                            // commands.spawn().add_child(p1).add_child(p2).insert(Stuck);
                        }
                    }
                } else {
                    if let Some((_, e)) = get_recursively::<Throwable>(world, *a) {
                        if world.get::<Destroyer>(*b).is_some() {
                            commands.entity(e).despawn_recursive();
                        }
                    }
                    if let Some((_, e)) = get_recursively::<Throwable>(world, *b) {
                        if world.get::<Destroyer>(*a).is_some() {
                            commands.entity(e).despawn_recursive();
                        }
                    }
                    continue;
                }
            }
            _ => {}
        }
        // info!("Received collision event: {collision_event:?}");
    }
}

/// Checks if either entity has a impulse joint which parent the other entity is
fn connected_by_impulse_joint(
    (a, joint_a): (Entity, Option<&ImpulseJoint>),
    (b, joint_b): (Entity, Option<&ImpulseJoint>),
) -> bool {
    return joint_a.map(|joint| joint.parent == b).unwrap_or(false)
        || joint_b.map(|joint| joint.parent == a).unwrap_or(false);
}
